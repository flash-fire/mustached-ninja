addop
$ ( id not num
args
$ ;
assignop
+ - $ ( id not num
comp_stmt
$ else end ; .
comp_stmtLF1
$ else end ; .
decs
procedure $ begin
decsLR1
procedure $ begin
expr
] $ else do then ) ; , end
exprLF1
] $ else do then ) ; , end
expr_list
$ )
expr_listLR1
$ )
factor
<= < ] >= else do <> mod ) - , end + and > = $ then / ; div * or
factorLF1
<= < ] >= else do <> mod ) - , end + and > = $ then / ; div * or
idList
$ )
idListLR1
$ )
mulop
$ ( id not num
opt_stmts
$ end
param_list
$ )
param_listLR1
$ )
prgm
$
prgmLF1
$
prgmLF1LF1
$
prgmLF1LF1LF1
$
prgmLF1LF2
$
prgmLF1LF2LF1
$
proc_stmt
$ else end ;
proc_stmtLF1
$ else end ;
relop
+ - $ ( id not num
sign
$ ( id not num
simple_expr
<= < ] >= > else do <> = $ then ) ; , end
simple_exprLR1
<= < ] >= > else do <> = $ then ) ; , end
std_type
$ ) ;
stmt
$ else end ;
stmtLF1
$ end ;
stmt_list
$ end
stmt_listLR1
$ end
subprgm_dec
$ ;
subprgm_decLF1
$ ;
subprgm_decLF1LF1
$ ;
subprgm_decs
$ begin
subprgm_decsLR1
$ begin
subprgm_head
procedure var $ begin
subprgm_headLF1
procedure var $ begin
term
<= < ] >= else do <> ) - , end + > = $ then ; or
termLR1
<= < ] >= else do <> ) - , end + > = $ then ; or
type
$ ) ;
variable
:= $
variableLF1
:= $
