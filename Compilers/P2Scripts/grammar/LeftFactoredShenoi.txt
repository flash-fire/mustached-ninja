prgm
	program id ( prgmLF1 
prgmLF1
	idList ) ; prgmLF1LF1 
	) ; prgmLF1LF2 
prgmLF1LF1
	comp_stmt . 
	decs prgmLF1LF1LF1 
	subprgm_decs comp_stmt . 
prgmLF1LF1LF1
	comp_stmt . 
	subprgm_decs comp_stmt . 
prgmLF1LF2
	comp_stmt . 
	subprgm_decs comp_stmt . 
	decs prgmLF1LF2LF1 
prgmLF1LF2LF1
	comp_stmt . 
	subprgm_decs comp_stmt . 
idList
	, id idListLR1 
idListLR1
	EPSILON
	, id idListLR1 
decs
	var id : type ; decsLR1 
decsLR1
	EPSILON
	var id : type ; decsLR1 
type
	std_type 
	array [ num .. num ] of std_type 
std_type
	real 
	integer 
subprgm_decs
	subprgm_dec ; subprgm_decsLR1 
subprgm_decsLR1
	subprgm_dec ; subprgm_decsLR1 
	EPSILON
subprgm_dec
	subprgm_head subprgm_decLF1 
subprgm_decLF1
	subprgm_decs comp_stmt 
	decs subprgm_decLF1LF1 
	comp_stmt 
subprgm_decLF1LF1
	subprgm_decs comp_stmt 
	comp_stmt 
subprgm_head
	procedure id subprgm_headLF1 
subprgm_headLF1
	args ; 
	; 
args
	( param_list ) 
param_list
	id : type param_listLR1 
param_listLR1
	EPSILON
	; id : type param_listLR1 
comp_stmt
	begin comp_stmtLF1 
comp_stmtLF1
	opt_stmts end 
	end 
opt_stmts
	stmt_list 
stmt_list
	stmt stmt_listLR1 
stmt_listLR1
	; stmt stmt_listLR1 
	EPSILON
stmt
	variable assignop expr 
	if expr then stmt stmtLF1 
	proc_stmt 
	while expr do stmt 
	comp_stmt 
stmtLF1
	EPSILON
	else stmt 
variable
	id variableLF1 
variableLF1
	EPSILON
	[ expr ] 
proc_stmt
	call id proc_stmtLF1 
proc_stmtLF1
	EPSILON
	( expr_list ) 
expr_list
	expr expr_listLR1 
expr_listLR1
	, expr expr_listLR1 
	EPSILON
expr
	simple_expr exprLF1 
exprLF1
	EPSILON
	relop simple_expr 
term
	factor termLR1 
termLR1
	mulop factor termLR1 
	EPSILON
simple_expr
	term simple_exprLR1 
	sign term simple_exprLR1 
simple_exprLR1
	addop term simple_exprLR1 
	EPSILON
factor
	( expr ) 
	id factorLF1 
	not factor 
	num 
factorLF1
	EPSILON
	[ expr ] 
sign
	- 
	+ 
addop
	- 
	+ 
	or 
assignop
	:= 
mulop
	and 
	/ 
	* 
	div 
	mod 
relop
	> 
	<= 
	= 
	>= 
	<> 
	< 
