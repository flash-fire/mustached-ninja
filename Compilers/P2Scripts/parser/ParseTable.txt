Terminal Order['(', ')', '*', '+', ',', '-', '.', '..', '/', ':', ':=', ';', '<', '<=', '<>', '=', '>', '>=', '[', ']', 'and', 'array', 'begin', 'call', 'div', 'do', 'else', 'end', 'id', 'if', 'integer', 'mod', 'not', 'num', 'of', 'or', 'procedure', 'program', 'real', 'then', 'var', 'while']
prgm
	program -> program id ( idList ) ; prgmLF1 
prgmLF1
	begin -> comp_stmt . 
	procedure -> subprgm_decs comp_stmt . 
	var -> decs prgmLF1LF1 
prgmLF1LF1
	begin -> comp_stmt . 
	procedure -> subprgm_decs comp_stmt . 
idList
	id -> id idListLR1 
idListLR1
	) -> EPSILON
	, -> , id idListLR1 
decs
	var -> var id : type ; decsLR1 
decsLR1
	begin -> EPSILON
	procedure -> EPSILON
	var -> var id : type ; decsLR1 
type
	array -> array [ num .. num ] of std_type 
	integer -> std_type 
	real -> std_type 
std_type
	integer -> integer 
	real -> real 
subprgm_decs
	procedure -> subprgm_dec ; subprgm_decsLR1 
subprgm_decsLR1
	begin -> EPSILON
	procedure -> subprgm_dec ; subprgm_decsLR1 
subprgm_dec
	procedure -> subprgm_head subprgm_decLF1 
subprgm_decLF1
	begin -> comp_stmt 
	procedure -> subprgm_decs comp_stmt 
	var -> decs subprgm_decLF1LF1 
subprgm_decLF1LF1
	begin -> comp_stmt 
	procedure -> subprgm_decs comp_stmt 
subprgm_head
	procedure -> procedure id subprgm_headLF1 
subprgm_headLF1
	( -> args ; 
	; -> ; 
args
	( -> ( param_list ) 
param_list
	id -> id : type param_listLR1 
param_listLR1
	) -> EPSILON
	; -> ; id : type param_listLR1 
comp_stmt
	begin -> begin comp_stmtLF1 
comp_stmtLF1
	begin -> opt_stmts end 
	call -> opt_stmts end 
	end -> end 
	id -> opt_stmts end 
	if -> opt_stmts end 
	while -> opt_stmts end 
opt_stmts
	begin -> stmt_list 
	call -> stmt_list 
	id -> stmt_list 
	if -> stmt_list 
	while -> stmt_list 
stmt_list
	begin -> stmt stmt_listLR1 
	call -> stmt stmt_listLR1 
	id -> stmt stmt_listLR1 
	if -> stmt stmt_listLR1 
	while -> stmt stmt_listLR1 
stmt_listLR1
	; -> ; stmt stmt_listLR1 
	end -> EPSILON
stmt
	begin -> comp_stmt 
	call -> proc_stmt 
	id -> variable assignop expr 
	if -> if expr then stmt stmtLF1 
	while -> while expr do stmt 
stmtLF1
	; -> EPSILON
	else -> else stmt 
	end -> EPSILON
variable
	id -> id variableLF1 
variableLF1
	:= -> EPSILON
	[ -> [ expr ] 
proc_stmt
	call -> call id proc_stmtLF1 
proc_stmtLF1
	( -> ( expr_list ) 
	; -> EPSILON
	else -> EPSILON
	end -> EPSILON
expr_list
	( -> expr expr_listLR1 
	+ -> expr expr_listLR1 
	- -> expr expr_listLR1 
	id -> expr expr_listLR1 
	not -> expr expr_listLR1 
	num -> expr expr_listLR1 
expr_listLR1
	) -> EPSILON
	, -> , expr expr_listLR1 
expr
	( -> simple_expr exprLF1 
	+ -> simple_expr exprLF1 
	- -> simple_expr exprLF1 
	id -> simple_expr exprLF1 
	not -> simple_expr exprLF1 
	num -> simple_expr exprLF1 
exprLF1
	) -> EPSILON
	, -> EPSILON
	; -> EPSILON
	< -> relop simple_expr 
	<= -> relop simple_expr 
	<> -> relop simple_expr 
	= -> relop simple_expr 
	> -> relop simple_expr 
	>= -> relop simple_expr 
	] -> EPSILON
	do -> EPSILON
	else -> EPSILON
	end -> EPSILON
	then -> EPSILON
term
	( -> factor termLR1 
	id -> factor termLR1 
	not -> factor termLR1 
	num -> factor termLR1 
termLR1
	) -> EPSILON
	* -> mulop factor termLR1 
	+ -> EPSILON
	, -> EPSILON
	- -> EPSILON
	/ -> mulop factor termLR1 
	; -> EPSILON
	< -> EPSILON
	<= -> EPSILON
	<> -> EPSILON
	= -> EPSILON
	> -> EPSILON
	>= -> EPSILON
	] -> EPSILON
	and -> mulop factor termLR1 
	div -> mulop factor termLR1 
	do -> EPSILON
	else -> EPSILON
	end -> EPSILON
	mod -> mulop factor termLR1 
	or -> EPSILON
	then -> EPSILON
simple_expr
	( -> term simple_exprLR1 
	+ -> sign term simple_exprLR1 
	- -> sign term simple_exprLR1 
	id -> term simple_exprLR1 
	not -> term simple_exprLR1 
	num -> term simple_exprLR1 
simple_exprLR1
	) -> EPSILON
	+ -> addop term simple_exprLR1 
	, -> EPSILON
	- -> addop term simple_exprLR1 
	; -> EPSILON
	< -> EPSILON
	<= -> EPSILON
	<> -> EPSILON
	= -> EPSILON
	> -> EPSILON
	>= -> EPSILON
	] -> EPSILON
	do -> EPSILON
	else -> EPSILON
	end -> EPSILON
	or -> addop term simple_exprLR1 
	then -> EPSILON
factor
	( -> ( expr ) 
	id -> id factorLF1 
	not -> not factor 
	num -> num 
factorLF1
	) -> EPSILON
	* -> EPSILON
	+ -> EPSILON
	, -> EPSILON
	- -> EPSILON
	/ -> EPSILON
	; -> EPSILON
	< -> EPSILON
	<= -> EPSILON
	<> -> EPSILON
	= -> EPSILON
	> -> EPSILON
	>= -> EPSILON
	[ -> [ expr ] 
	] -> EPSILON
	and -> EPSILON
	div -> EPSILON
	do -> EPSILON
	else -> EPSILON
	end -> EPSILON
	mod -> EPSILON
	or -> EPSILON
	then -> EPSILON
sign
	+ -> + 
	- -> - 
addop
	+ -> + 
	- -> - 
	or -> or 
assignop
	:= -> := 
mulop
	* -> * 
	/ -> / 
	and -> and 
	div -> div 
	mod -> mod 
relop
	< -> < 
	<= -> <= 
	<> -> <> 
	= -> = 
	> -> > 
	>= -> >= 
