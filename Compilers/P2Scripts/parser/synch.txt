addop
$ id num not (
args
$ ;
assignop
- + id $ num ( not
comp_stmt
$ ; else end .
comp_stmtLF1
$ ; else end .
decs
$ procedure begin
decsLR1
$ procedure begin
expr
else end ) ; do $ , then ]
exprLF1
else end ) ; do $ , then ]
expr_list
$ )
expr_listLR1
$ )
factor
* <> else end ) <= = do < $ then >= ] - + and div / ; mod or , >
factorLF1
* <> else end ) <= = do < $ then >= ] - + and div / ; mod or , >
mulop
$ id num not (
opt_stmts
$ end
param_list
$ )
param_listLR1
$ )
prgm
$
prgmLF1
$
prgmLF1LF1
$
proc_stmt
$ ; else end
proc_stmtLF1
$ ; else end
relop
- + id $ num ( not
sign
$ id num not (
simple_expr
] <> else end ) <= = ; do < $ , > >= then
simple_exprLR1
] <> else end ) <= = ; do < $ , > then >=
std_type
$ ; )
stmt
$ ; else end
stmtLF1
$ ; end
stmt_list
$ end
stmt_listLR1
$ end
subprgm_dec
$ ;
subprgm_decLF1
$ ;
subprgm_decLF1LF1
$ ;
subprgm_decs
$ begin
subprgm_decsLR1
$ begin
subprgm_head
$ var procedure begin
subprgm_headLF1
$ var procedure begin
term
<> else end ) <= = do < $ then >= ] - + ; or , >
termLR1
<> else end ) <= = do < $ then >= ] - + ; or , >
type
$ ; )
variable
$ :=
variableLF1
$ :=
