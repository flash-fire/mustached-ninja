prgm_1:
	<<vars>> totalSize
	<<begin>> program_1 id_1 (_1 idList_1 )_1 ;_1 prgmLF1_1 <<end>> 
		id_1
			currScope = new Scope(NULL, prgm_1->findT("id_1")->lex);
			std::cout << prgm_1->findT("id_1")->lex;
		<<end>>
			prgm_1->set("totalSize", prgmLF1_1->get("totalSize"));
prgmLF1_1:
	<<vars>> totalSize
	<<begin>> comp_stmt_1 ._1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 ._1 <<end>> 
	<<begin>> decs_1 prgmLF1LF1_1 <<end>> 
		<<begin>>
			decs_1->set("offset", 0);
		<<end>>
			prgmLF1_1->set("totalSize", decs_1->get("totalSize"));
		<<error>>
			prgmLF1_1->set("totalSize", 0);
prgmLF1LF1_1:
	<<begin>> comp_stmt_1 ._1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 ._1 <<end>> 
idList_1:
	<<begin>> id_1 idListLR1_1 <<end>> 
idListLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> ,_1 id_1 idListLR1_2 <<end>> 
decs_1:
	<<vars>> totalSize offset t
	<<begin>> var_1 id_1 :_1 type_1 ;_1 decsLR1_1 <<end>>
		type_1
			decsLR1_1->set("offset", decs_1->get("offset") + type_1->get("width")); //# debug later
			Token* idTok = decs_1->findT("id_1");
			std::string ret = "";
			std::string* err = &ret;
			if (currScope->addVar(idTok->lex, ITT(type_1->get("t")), decs_1->get("offset"), err) == false)
			{
				target << *err << " VAR NAME: " << idTok->lex << " LINE # " << idTok->line << "\n";
			}
		<<end>>
			decs_1->set("t", decsLR1_1->get("t"));
			decs_1->set("totalSize", decsLR1_1->get("totalSize"));
	<<error>>
		decs_1->set("t", TTI(ERROR));
		decs_1->set("totalSize", 0);
decsLR1_1:
	<<vars>> totalSize offset t
	<<begin>> EPSILON <<end>> 
		<<end>>
			decsLR1_1->set("totalSize", decsLR1_1->get("offset"));
			decsLR1_1->set("t", TTI(NONE));
	<<begin>> var_1 id_1 :_1 type_1 ;_1 decsLR1_2 <<end>> 
		type_1
			decsLR1_2->set("offset", decsLR1_1->get("offset") + type_1->get("width")); //# ADDRESS
			Token* idTok = decsLR1_1->findT(1); //# SCOPE
			std::string ret = "";
			std::string* err = &ret;
			if (currScope->addVar(idTok->lex, ITT(type_1->get("t")), decsLR1_1->get("offset"), err) == false)
			{
				target << *err << " VAR NAME: " << idTok->lex << " LINE # " << idTok->line << "\n";
			}
		<<end>>
			decsLR1_1->set("t", decsLR1_2->get("t"));
			decsLR1_1->set("totalSize", decsLR1_2->get("totalSize"));
	<<error>>
		decsLR1_1->set("t", TTI(ERROR));
		decsLR1_1->set("totalSize", 0);
type_1:
	<<vars>> t width
	<<begin>> std_type_1 <<end>>
		<<end>>
			type_1->set("t", std_type_1->get("t"));
			type_1->set("width", std_type_1->get("width"));
	<<begin>> array_1 [_1 num_1 .._1 num_2 ]_1 of_1 std_type_1 <<end>>
		<<end>>
			Token* tok1 = type_1->findT("num_1"); //# Yes this may seem unsafe, but I only have to do this for arrays so I'm okay with it.
			Token* tok2 = type_1->findT("num_2");
			type_1->set("t",TTI(ERROR)); //# Defaulting to error unless changed
			type_1->set("width", 0);
			
			int min = -1;
			int max = -1;
			int arraySize = 0;
			int i = 0; //# Terrible hack is great hack!
			for (Token* currTok : {tok1, tok2})
			{
				if (currTok->isInt())
				{
					if (i == 0)
						min = currTok->val();
					else if (i == 1)
						max = currTok->val();
					else
						std::cout << "WTF in array terrible hack";
				}
				else if (currTok->isReal())
				{
					TypeErrorTok(nt, Type::INT, Type::REAL, *currTok);
				}
				else
				{ //# I highly doubt this line will be reached because currTok must be valid syntactically for this to be reached.
				  //# Therefore, I added this just in case I get it. IT's a nice "MY COMPILER HAS A BUG" output.
				TypeErrorTok(nt, Type::INT, Type::UNASSIGNED, *currTok);
				}
				i++;
			}
			arraySize = max - min;
			if (max == -1 || min == -1)
			{ // error would be already reported at above
			
			}
			else if (arraySize <= 0) //# if bad args
			{
				target << "SEMERR: Array parameters improper. Min >= Max with " << tok1->lex << " and " << tok2->lex << "\n\n";
			}
			else 
			{
				int t_ = std_type_1->get("t");
				if (t_ == TTI(INT))
				{
					type_1->set("t", TTI(AINT));
					type_1->set("width", std_type_1->get("width") * arraySize);
				}
				if (t_ == TTI(REAL))
				{
					type_1->set("t", TTI(AREAL));
					type_1->set("width", std_type_1->get("width") * arraySize);
				}
				 //# FINALLY all the silly errors are done
			}
			std::cout << "\nMade array of type " << Type::typeToString(ITT(type_1->get("t"))) << " width " << type_1->get("width");

	<<error>> //# no need to say that the array has an error when you have a syntax error. You got problems. You already know.
		type_1->set("t", TTI(ERROR));
		type_1->set("width", 0);
std_type_1:
	<<vars>> t width
	<<begin>> real_1 <<end>> 
		<<end>>
			std_type_1->set("width", 8);
			std_type_1->set("t", TTI(REAL));
	<<begin>> integer_1 <<end>>
		<<end>>
			std_type_1->set("width", 4);
			std_type_1->set("t", TTI(INT));
	<<error>>
		std_type_1->set("t", TTI(ERROR));
		std_type_1->set("width", 0);
subprgm_decs_1:
	<<begin>> subprgm_dec_1 ;_1 subprgm_decsLR1_1 <<end>> 
		<<begin>>
			Scope* dummyScope = new Scope(currScope, "~~DUMMY~~"); //# SCOPE
			scopeDepth++;
			std::string* err = &std::string();
			currScope->addChild(dummyScope, err); //# This call will never error. Thank god.
			if (*err != "")
			{
				std::cout  << " ANGRY ANGRY ANGRY IMPOSSIBLE ASSERTION LIKE THING ENCOUNTERED. DUMMY SCOPE! DUMMYSCOPE! FEEL ANGER YOU SHUOLD! YOU ANGRISH!\n";
			}
			currScope = dummyScope;
subprgm_decsLR1_1:
	<<begin>> EPSILON <<end>>
		<<end>>
			currScope = currScope->getParent(); //# SCOPE
	<<begin>> subprgm_dec_1 ;_1 subprgm_decsLR1_2 <<end>> 
subprgm_dec_1:
	<<vars>> first
	<<begin>> subprgm_head_1 subprgm_decLF1_1 <<end>>
		subprgm_head_1
			subprgm_decLF1_1->set("totalSize", subprgm_head_1->get("totalSize")); //# pass back address totalSize for params
subprgm_decLF1_1:
	<<vars>> totalSize
	<<begin>> decs_1 subprgm_decLF1LF1_1 <<end>> 
		<<begin>>
			decs_1->set("offset", subprgm_decLF1_1->get("totalSize")); //# receive address offset for params
	<<begin>> comp_stmt_1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 <<end>> 
subprgm_decLF1LF1_1:
	<<begin>> comp_stmt_1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 <<end>> 
subprgm_head_1:
	<<vars>> totalSize t
	<<begin>> procedure_1 id_1 subprgm_headLF1_1 <<end>> 
		id_1
			Token* tok = subprgm_head_1->findT("id_1");
			Scope* currSib = new Scope(currScope->getParent(), tok->lex);
			std::string* errMsg = &std::string();
			std::cout << std::string(scopeDepth * 2, ' ') << tok->lex << "\n" << "\n";
			if (currScope->addSibling(currSib, errMsg) == false)
			{
				target << *errMsg << "\n\ton line " << tok->line << " and collumn " << tok->charNum  << "\n";
			}
			currScope = currSib;
		<<end>>
			subprgm_head_1->set("totalSize", subprgm_headLF1_1->get("totalSize")); //# pass back address address offset for params
			subprgm_head_1->set("t", subprgm_headLF1_1->get("t"));
		<<error>>
			subprgm_head_1->set("t", TTI(ERROR));
			subprgm_head_1->set("totalSize", 0);
subprgm_headLF1_1:
	<<vars>> totalSize t
	<<begin>> args_1 ;_1 <<end>> 
		<<end>>
			subprgm_headLF1_1->set("totalSize", args_1->get("totalSize"));
			subprgm_headLF1_1->set("t", args_1->get("t"));
	<<begin>> ;_1 <<end>> 
		<<end>>
			subprgm_headLF1_1->set("totalSize", 0);
			subprgm_headLF1_1->set("t", TTI(NONE));
	<<error>>
		subprgm_headLF1_1->set("t", TTI(ERROR));
		subprgm_headLF1_1->set("totalSize", 0);
args_1:
	<<vars>> totalSize offset t
	<<begin>> (_1 param_list_1 )_1 <<end>> 
		<<end>>
			args_1->set("totalSize", param_list_1->get("totalSize"));
			args_1->set("t", param_list_1->get("t"));
		<<error>>
			args_1->set("t", TTI(ERROR));
			args_1->set("totalSize", 0);
param_list_1:
	<<vars>> totalSize offset t
	<<begin>> id_1 :_1 type_1 param_listLR1_1 <<end>> 
		type_1
			param_listLR1_1->set("offset", param_list_1->get("offset") + type_1->get("width")); //# OFFSET STARTS AT 0 BECAUSE PARAMS
			Token* idTok = param_list_1->findT("id_1");
			std::string ret = "";
			std::string* err = &ret;
			if (currScope->addParam(idTok->lex, ITT(type_1->get("t")), param_list_1->get("offset"), err) == false)
			{
				target << *err << " VAR NAME: " << idTok->lex << " LINE # " << idTok->line << "\n";
			}
		<<end>>
			param_list_1->set("t", param_listLR1_1->get("t"));
			param_list_1->set("totalSize", param_listLR1_1->get("totalSize"));
param_listLR1_1:
	<<vars>> totalSize offset t
	<<begin>> EPSILON <<end>> 
		<<end>>
			param_listLR1_1->set("totalSize", param_listLR1_1->get("offset"));
			param_listLR1_1->set("t", TTI(NONE));
	<<begin>> ;_1 id_1 :_1 type_1 param_listLR1_2 <<end>> 
		type_1
			param_listLR1_2->set("offset", param_listLR1_1->get("offset") + type_1->get("width")); //# ADDRESS
			Token* idTok = param_listLR1_1->findT(1); //# SCOPE
			std::string ret = "";
			std::string* err = &ret;
			if (currScope->addParam(idTok->lex, ITT(type_1->get("t")), param_listLR1_1->get("offset"), err) == false)
			{
				target << *err << " VAR NAME: " << idTok->lex << " LINE # " << idTok->line << "\n";
			}
		<<end>>
			param_listLR1_1->set("t", param_listLR1_2->get("t"));
			param_listLR1_1->set("totalSize", param_listLR1_2->get("totalSize"));
	<<error>>
		param_listLR1_1->set("t", TTI(ERROR));
		param_listLR1_1->set("totalSize", 0);
comp_stmt_1:
	<<begin>> begin_1 comp_stmtLF1_1 <<end>> 
comp_stmtLF1_1:
	<<begin>> end_1 <<end>> 
	<<begin>> opt_stmts_1 end_1 <<end>> 
opt_stmts_1:
	<<begin>> stmt_list_1 <<end>> 
stmt_list_1:
	<<begin>> stmt_1 stmt_listLR1_1 <<end>> 
stmt_listLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> ;_1 stmt_1 stmt_listLR1_2 <<end>> 
stmt_1:
	<<begin>> variable_1 assignop_1 expr_1 <<end>> 
	<<begin>> proc_stmt_1 <<end>> 
	<<begin>> comp_stmt_1 <<end>> 
	<<begin>> while_1 expr_1 do_1 stmt_2 <<end>> 
	<<begin>> if_1 expr_1 then_1 stmt_2 stmtLF1_1 <<end>> 
stmtLF1_1:
	<<begin>> else_1 stmt_1 <<end>> 
	<<begin>> EPSILON <<end>> 
variable_1:
	<<begin>> id_1 variableLF1_1 <<end>> 
variableLF1_1:
	<<begin>> [_1 expr_1 ]_1 <<end>> 
	<<begin>> EPSILON <<end>> 
proc_stmt_1:
	<<begin>> call_1 id_1 proc_stmtLF1_1 <<end>> 
	id_1
		proc_stmtLF1_1->leSigh = &proc_stmt_1->findT("id_1")->lex; //# Making a one time use pointer in ParseNode just to make this decorating easier and safer.
proc_stmtLF1_1:
	<<begin>> EPSILON <<end>> 
		<<end>>
			std::string procID = *proc_stmtLF1_1->leSigh;
			if (currScope->isProcCallable(procID))
			{
				if (currScope->getParams(procID).size() == 0)
				{
					proc_stmtLF1_1->set("t", TTI(NONE));
					goto endCode;
				}
				else
				{
					target << "SEMERR: Expected " << std::to_string(currScope->getParams(procID).size()) << " parameters, but received none on line " << lookAhead.line << "\n";
				}
			}
			else
			{
				target << "SEMERR: Procedure " << procID << " is not in scope on line " << lookAhead.line << "\n";
			}
			proc_stmtLF1_1->set("t", TTI(ERROR));
			endCode:
	<<begin>> (_1 expr_list_1 )_1 <<end>> 
		<<begin>>
			expr_list_1->leSigh = proc_stmtLF1_1->leSigh;
			//expr_list_1->set("ind",0);
		<<end>>
			//proc_stmtLF1_1->set("t", expr_list_1->get("t"));
expr_list_1:
	<<begin>> expr_1 expr_listLR1_1 <<end>> 
expr_listLR1_1:
	<<begin>> ,_1 expr_1 expr_listLR1_2 <<end>> 
	<<begin>> EPSILON <<end>> 
expr_1:
	<<begin>> simple_expr_1 exprLF1_1 <<end>> 
exprLF1_1:
	<<begin>> relop_1 simple_expr_1 <<end>> 
	<<begin>> EPSILON <<end>> 
term_1:
	<<begin>> factor_1 termLR1_1 <<end>> 
termLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> mulop_1 factor_1 termLR1_2 <<end>> 
simple_expr_1:
	<<begin>> sign_1 term_1 simple_exprLR1_1 <<end>> 
	<<begin>> term_1 simple_exprLR1_1 <<end>> 
simple_exprLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> addop_1 term_1 simple_exprLR1_2 <<end>> 
factor_1:
	<<vars>> t
	<<begin>> id_1 factorLF1_1 <<end>> 
			id_1
				Token* tok = factor_1->findT("id_1");
				std::string id = tok->lex;
				if (currScope->isVarInScope(id))
				{
					std::string* err = &std::string();
					Type::TYPE foundType = currScope->getTypeOfVar(id, err);
					int t = foundType;
					factorLF1_1->set("i", t);
					if (*err != "")
					{
						std::cout << " UNEXPECTED ERR IN FACTOR: " << *err;
					}
				}
				else
				{
					target << "SEMERR : attempting to use uninitialized variable: " + id + " on line " + std::to_string(tok->line); +" char position " + std::to_string(tok->charNum) + "\n";
				}
		<<end>>
			factor_1->set("t", TTI(NONE)); //# place holder
	<<begin>> num_1 <<end>>
		num_1
			Token* num = factor_1->findT("num_1");
			if (num->isInt())
				factor_1->set("t", TTI(INT));
			else if (num->isReal())
				factor_1->set("t", TTI(REAL));
			else
				factor_1->set("t", TTI(ERROR));
	<<begin>> (_1 expr_1 )_1 <<end>> 
		<<end>>
			factor_1->set("t", TTI(NONE));
	<<begin>> not_1 factor_2 <<end>> 
		<<end>>
			factor_1->set("t", TTI(NONE));
factorLF1_1:
	<<vars>> i
	<<begin>> [_1 expr_1 ]_1 <<end>> 
	<<begin>> EPSILON <<end>> 
sign_1:
	<<begin>> -_1 <<end>> 
	<<begin>> +_1 <<end>> 
addop_1:
	<<begin>> -_1 <<end>> 
	<<begin>> +_1 <<end>> 
	<<begin>> or_1 <<end>> 
assignop_1:
	<<begin>> :=_1 <<end>> 
mulop_1:
	<<begin>> and_1 <<end>> 
	<<begin>> mod_1 <<end>> 
	<<begin>> /_1 <<end>> 
	<<begin>> *_1 <<end>> 
	<<begin>> div_1 <<end>> 
relop_1:
	<<begin>> >_1 <<end>> 
	<<begin>> >=_1 <<end>> 
	<<begin>> <_1 <<end>> 
	<<begin>> <=_1 <<end>> 
	<<begin>> =_1 <<end>> 
	<<begin>> <>_1 <<end>> 
