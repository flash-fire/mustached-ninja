prgm_1:
	<<begin>> program_1 id_1 (_1 idList_1 )_1 ;_1 prgmLF1_1 <<end>> 
prgmLF1_1:
	<<begin>> comp_stmt_1 ._1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 ._1 <<end>> 
	<<begin>> decs_1 prgmLF1LF1_1 <<end>> 
prgmLF1LF1_1:
	<<begin>> comp_stmt_1 ._1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 ._1 <<end>> 
idList_1:
	<<begin>> id_1 idListLR1_1 <<end>> 
idListLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> ,_1 id_1 idListLR1_2 <<end>> 
decs_1:
	<<begin>> var_1 id_1 :_1 type_1 ;_1 decsLR1_1 <<end>> 
decsLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> var_1 id_1 :_1 type_1 ;_1 decsLR1_2 <<end>> 
type_1:
	<<vars>> t width
	<<begin>> std_type_1 <<end>>
		<<end>>
			type_1->set("t", std_type_1->get("t"));
			type_1->set("width", std_type_1->get("width"));
	<<begin>> array_1 [_1 num_1 .._1 num_2 ]_1 of_1 std_type_1 <<end>>
		<<end>>
			Token* tok1 = type_1->findT("num_1");
			Token* tok2 = type_1->findT("num_2");
			type_1->set("t",TTI(ERROR)); //# Defaulting to error unless changed
			type_1->set("width", 0);
			
			int min = -1;
			int max = -1;
			int arraySize = 0;
			int i = 0; //# Terrible hack is great hack!
			for (Token* currTok : {tok1, tok2})
			{
				if (currTok->isInt())
				{
					if (i == 0)
						min = currTok->val();
					else if (i == 1)
						max = currTok->val();
					else
						std::cout << "WTF in array terrible hack";
				}
				else if (tok1->isReal())
				{
					TypeErrorTok(nt, Type::INT, Type::REAL, *currTok);
				}
				else
				{
					TypeErrorTok(nt, Type::INT, Type::UNASSIGNED, *currTok);
				}
				i++;
			}
			arraySize = max - min;
			if (max == -1 || min == -1 || arraySize < 0) //# if bad args
			{
				if (arraySize < 0)
				{
					target << "SEMERROR: Array parameters improper. Min >= Max with " << tok1->lex << " and " << tok2->lex
						<< "\n";
				}
			}
			else 
			{
				int t_ = std_type_1->get("t");
				if (t_ == TTI(INT))
				{
					type_1->set("t", TTI(AINT));
					type_1->set("width", std_type_1->get("width") * arraySize);
				}
				if (t_ == TTI(REAL))
				{
					type_1->set("t", TTI(AREAL));
					type_1->set("width", std_type_1->get("width") * arraySize);
				}
				 //# FINALLY all the silly errors are done
			}
			std::cout << "Made array of type " << Type::typeToString(ITT(type_1->get("t"))) << " width " << type_1->get("width") << "\n";
	<<error>> //# no need to say that the array has an error when you have a syntax error. You got problems. You already know.
		type_1->set("t", TTI(ERROR));
		type_1->set("width", 0);
std_type_1:
	<<vars>> t width
	<<begin>> real_1 <<end>> 
		<<end>>
			std_type_1->set("width", 8);
			std_type_1->set("t", TTI(REAL));
	<<begin>> integer_1 <<end>>
		<<end>>
			std_type_1->set("width", 4);
			std_type_1->set("t", TTI(INT));
	<<error>>
		
		std_type_1->set("t", TTI(ERROR));
		std_type_1->set("width", 0);
subprgm_decs_1:
	<<begin>> subprgm_dec_1 ;_1 subprgm_decsLR1_1 <<end>> 
subprgm_decsLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> subprgm_dec_1 ;_1 subprgm_decsLR1_2 <<end>> 
subprgm_dec_1:
	<<begin>> subprgm_head_1 subprgm_decLF1_1 <<end>> 
subprgm_decLF1_1:
	<<begin>> decs_1 subprgm_decLF1LF1_1 <<end>> 
	<<begin>> comp_stmt_1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 <<end>> 
subprgm_decLF1LF1_1:
	<<begin>> comp_stmt_1 <<end>> 
	<<begin>> subprgm_decs_1 comp_stmt_1 <<end>> 
subprgm_head_1:
	<<begin>> procedure_1 id_1 subprgm_headLF1_1 <<end>> 
subprgm_headLF1_1:
	<<begin>> args_1 ;_1 <<end>> 
	<<begin>> ;_1 <<end>> 
args_1:
	<<begin>> (_1 param_list_1 )_1 <<end>> 
param_list_1:
	<<begin>> id_1 :_1 type_1 param_listLR1_1 <<end>> 
param_listLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> ;_1 id_1 :_1 type_1 param_listLR1_2 <<end>> 
comp_stmt_1:
	<<begin>> begin_1 comp_stmtLF1_1 <<end>> 
comp_stmtLF1_1:
	<<begin>> end_1 <<end>> 
	<<begin>> opt_stmts_1 end_1 <<end>> 
opt_stmts_1:
	<<begin>> stmt_list_1 <<end>> 
stmt_list_1:
	<<begin>> stmt_1 stmt_listLR1_1 <<end>> 
stmt_listLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> ;_1 stmt_1 stmt_listLR1_2 <<end>> 
stmt_1:
	<<begin>> variable_1 assignop_1 expr_1 <<end>> 
	<<begin>> proc_stmt_1 <<end>> 
	<<begin>> comp_stmt_1 <<end>> 
	<<begin>> while_1 expr_1 do_1 stmt_2 <<end>> 
	<<begin>> if_1 expr_1 then_1 stmt_2 stmtLF1_1 <<end>> 
stmtLF1_1:
	<<begin>> else_1 stmt_1 <<end>> 
	<<begin>> EPSILON <<end>> 
variable_1:
	<<begin>> id_1 variableLF1_1 <<end>> 
variableLF1_1:
	<<begin>> [_1 expr_1 ]_1 <<end>> 
	<<begin>> EPSILON <<end>> 
proc_stmt_1:
	<<begin>> call_1 id_1 proc_stmtLF1_1 <<end>> 
proc_stmtLF1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> (_1 expr_list_1 )_1 <<end>> 
expr_list_1:
	<<begin>> expr_1 expr_listLR1_1 <<end>> 
expr_listLR1_1:
	<<begin>> ,_1 expr_1 expr_listLR1_2 <<end>> 
	<<begin>> EPSILON <<end>> 
expr_1:
	<<begin>> simple_expr_1 exprLF1_1 <<end>> 
exprLF1_1:
	<<begin>> relop_1 simple_expr_1 <<end>> 
	<<begin>> EPSILON <<end>> 
term_1:
	<<begin>> factor_1 termLR1_1 <<end>> 
termLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> mulop_1 factor_1 termLR1_2 <<end>> 
simple_expr_1:
	<<begin>> sign_1 term_1 simple_exprLR1_1 <<end>> 
	<<begin>> term_1 simple_exprLR1_1 <<end>> 
simple_exprLR1_1:
	<<begin>> EPSILON <<end>> 
	<<begin>> addop_1 term_1 simple_exprLR1_2 <<end>> 
factor_1:
	<<begin>> id_1 factorLF1_1 <<end>> 
	<<begin>> num_1 <<end>> 
	<<begin>> (_1 expr_1 )_1 <<end>> 
	<<begin>> not_1 factor_2 <<end>> 
factorLF1_1:
	<<begin>> [_1 expr_1 ]_1 <<end>> 
	<<begin>> EPSILON <<end>> 
sign_1:
	<<begin>> -_1 <<end>> 
	<<begin>> +_1 <<end>> 
addop_1:
	<<begin>> -_1 <<end>> 
	<<begin>> +_1 <<end>> 
	<<begin>> or_1 <<end>> 
assignop_1:
	<<begin>> :=_1 <<end>> 
mulop_1:
	<<begin>> and_1 <<end>> 
	<<begin>> mod_1 <<end>> 
	<<begin>> /_1 <<end>> 
	<<begin>> *_1 <<end>> 
	<<begin>> div_1 <<end>> 
relop_1:
	<<begin>> >_1 <<end>> 
	<<begin>> >=_1 <<end>> 
	<<begin>> <_1 <<end>> 
	<<begin>> <=_1 <<end>> 
	<<begin>> =_1 <<end>> 
	<<begin>> <>_1 <<end>> 
